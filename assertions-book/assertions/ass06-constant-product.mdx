---
title: Constant Product
description: Assert that a constant product is maintained in an AMM pool
---

## Use Case
Check if the constant product (k = x * y) is maintained in an AMM pool. This is a critical security parameter for Automated Market Maker (AMM) protocols as it ensures:

- Prevention of unauthorized manipulation of pool reserves
- Detection of potential flash loan attacks that could drain the pool
- Verification that trades maintain the expected mathematical relationship between assets
- Protection against arithmetic overflow/underflow vulnerabilities in reserve calculations

The constant product formula (k = x * y) is fundamental to many AMM designs, particularly those following the Uniswap V2 model. Any deviation from this invariant could indicate a serious security issue or potential exploit.

### Applicable Protocols
- Uniswap V2-style AMMs that use the x * y = k formula
- DEX aggregators that interact with constant product pools
- Lending protocols that use AMM pools as price oracles
- Yield farming protocols that provide liquidity to AMM pools

These protocols rely heavily on the constant product invariant for:
- Price discovery and trading
- Liquidity provision calculations
- Fee calculations
- Oracle price feeds

## Explanation
The assertion monitors the product of reserves (k) in an AMM pool to ensure it remains constant after transactions:

1. Pre-state verification: Captures the initial state of pool reserves
2. Post-state verification: Checks the final state after transactions
3. Constant product validation: Ensures k = reserve0 * reserve1 remains unchanged

The assertion uses the following cheatcodes:
- `forkPreState()`: Creates a fork of the state before the transaction to capture initial reserves
- `forkPostState()`: Creates a fork of the state after the transaction to verify final reserves
- `getStateChanges()`: Monitors reserve changes throughout the transaction callstack to detect potential manipulations

This multi-layered approach is particularly important because:
- It catches manipulations that might happen during the transaction but get "fixed" by the end (e.g., a malicious contract that temporarily modifies reserves)
- It prevents flash loan attacks that try to manipulate reserves temporarily to extract value
- It ensures the constant product is maintained at every step of the transaction, not just the beginning and end
- It provides protection against complex attack vectors that might try to exploit the timing of reserve changes

> **Note:** This assertion demonstrates the flexibility of Phylax assertions by combining different approaches:
> - Using contract functions (`getReserves()`) for pre/post state verification
> - Using direct storage access (`getStateChanges`) for monitoring intermediate states
> 
> This hybrid approach allows developers to:
> - Use existing contract interfaces when available and well-tested
> - Access storage directly when needed for more granular control
> - Combine both approaches to create more robust assertions

For more information about cheatcodes, see the [Cheatcodes Documentation](/credible/cheatcodes).

## Code Example
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

import {Assertion} from "credible-std/Assertion.sol";
import {PhEvm} from "credible-std/PhEvm.sol";

// Aerodrome style pool interface
interface IAmm {
    function getReserves() external view returns (uint256, uint256);
}

contract ConstantProductAssertion is Assertion {
    IAmm public amm = IAmm(address(0xbeef));

    function triggers() external view override {
        // Register triggers for both reserve slots for each assertion
        // This ensures we catch any modifications to either reserve
        
        // Main constant product assertion
        registerStorageChangeTrigger(this.assertionConstantProduct.selector, bytes32(uint256(0)));
        registerStorageChangeTrigger(this.assertionConstantProduct.selector, bytes32(uint256(1)));
        
        // Reserve0 specific assertion
        registerStorageChangeTrigger(this.assertionReserve0Changes.selector, bytes32(uint256(0)));
        
        // Reserve1 specific assertion
        registerStorageChangeTrigger(this.assertionReserve1Changes.selector, bytes32(uint256(1)));
    }

    // Assert that the constant product (k = x * y) invariant is maintained
    // This is done through a multi-layered approach:
    // 1. Verify the initial state (kPre)
    // 2. Monitor all intermediate states during the transaction
    // 3. Verify the final state matches the initial state (kPost == kPre)
    function assertionConstantProduct() external {
        // Get pre-state reserves and calculate initial k
        ph.forkPreState();
        (uint256 reserve0Pre, uint256 reserve1Pre) = amm.getReserves();
        uint256 kPre = reserve0Pre * reserve1Pre;

        // Get post-state reserves and calculate final k
        ph.forkPostState();
        (uint256 reserve0Post, uint256 reserve1Post) = amm.getReserves();
        uint256 kPost = reserve0Post * reserve1Post;

        // Verify the final state maintains the constant product
        require(kPre == kPost, "Constant product invariant violated");
    }

    // Assert that reserve0 changes maintain the constant product invariant
    // Note: This is a simplified version that assumes reserves are always updated simultaneously.
    // Different AMM implementations might have edge cases where reserves are updated independently
    // or at different times in the transaction. For those cases, a more sophisticated assertion
    // might be needed that tracks the chronological order of changes.
    function assertionReserve0Changes() external {
        // Get pre-state reserves and calculate initial k
        ph.forkPreState();
        (uint256 reserve0Pre, uint256 reserve1Pre) = amm.getReserves();
        uint256 kPre = reserve0Pre * reserve1Pre;

        // Get all state changes for reserve0 slot
        uint256[] memory reserve0Changes = getStateChangesUint(address(amm), bytes32(uint256(0)));

        // Verify each change maintains the constant product with the initial reserve1
        for (uint256 i = 0; i < reserve0Changes.length; i++) {
            require(reserve0Changes[i] * reserve1Pre == kPre, "Reserve0 modification violates constant product");
        }
    }

    // Assert that reserve1 changes maintain the constant product invariant
    // Note: This is a simplified version that assumes reserves are always updated simultaneously.
    // Different AMM implementations might have edge cases where reserves are updated independently
    // or at different times in the transaction. For those cases, a more sophisticated assertion
    // might be needed that tracks the chronological order of changes.
    function assertionReserve1Changes() external {
        // Get pre-state reserves and calculate initial k
        ph.forkPreState();
        (uint256 reserve0Pre, uint256 reserve1Pre) = amm.getReserves();
        uint256 kPre = reserve0Pre * reserve1Pre;

        // Get all state changes for reserve1 slot
        uint256[] memory reserve1Changes = getStateChangesUint(address(amm), bytes32(uint256(1)));

        // Verify each change maintains the constant product with the initial reserve0
        for (uint256 i = 0; i < reserve1Changes.length; i++) {
            require(reserve0Pre * reserve1Changes[i] == kPre, "Reserve1 modification violates constant product");
        }
    }
}
```

> **Note:** This code example is maintained in the [Phylax Assertion Examples Repository](https://github.com/phylaxsystems/assertion-examples/blob/main/assertions/assertions_book/). For the latest version and a test example, please refer to the repository.

## Testing
To test this assertion:
1. Deploy an AMM pool with the constant product formula
2. Set up the assertion contract with the pool address
3. Test various scenarios:
   - Normal trades that maintain the constant product
   - Edge cases with very small/large numbers
   - Attempted manipulations that should be caught
   - Flash loan attacks that try to drain the pool

## Assertion Best Practices
- Consider combining this assertion with [Fee Calculations](/assertions-book/assertions/ass14-fee-calculations) for comprehensive AMM security
- Use precise arithmetic checks to prevent rounding errors from triggering false positives
- Monitor both reserve slots to catch any unauthorized modifications
- Add detailed error messages to help with debugging when assertions fail

## Related Assertions
- [Fee Calculations](/assertions-book/assertions/ass14-fee-calculations)
- [ERC20 Drain](/assertions-book/assertions/ass20-erc20-drain)
- [Panic State Validation](/assertions-book/assertions/ass17-panic-state-validation)
- [Intra Transaction Oracle Deviation](/assertions-book/assertions/ass28-intra-tx-oracle-deviation)
