---
title: ERC4626 Vault Deposit
description: Assert that ERC4626 deposit maintain correct share accounting
---

## Use Case
ERC4626 is a standard for creating yield-bearing tokens that are compatible with ERC20. This assertion ensures that deposit operations maintain correct accounting for both assets and shares, which are critical security parameters for any ERC4626 vault.

This assertion is particularly important for:
- Preventing share calculation errors that could lead to loss of user funds
- Ensuring deposits maintain the correct ratio between assets and shares
- Detecting potential accounting errors in yield-bearing vaults
- Maintaining protocol security by enforcing share calculation invariants

For example, if a vault incorrectly calculates shares during deposits, users could receive fewer shares than they should, effectively losing value in their deposits.

### Applicable Protocols
- Yield aggregators that use ERC4626 for their vaults (e.g., Yearn, Aave, Compound)
- Lending protocols that implement ERC4626 for their interest-bearing tokens
- Liquidity pools that use ERC4626 for their LP tokens
- Staking protocols that implement ERC4626 for their staking tokens

## Explanation
The assertion is split into two separate checks to ensure comprehensive verification of deposit operations:

1. **Asset Accounting Check**: Verifies that the total assets in the vault increase by exactly the amount deposited. This ensures that no assets are lost or duplicated during deposits.

2. **Share Accounting Check**: Verifies that each depositor receives the correct number of shares for their deposit. This is done by comparing the actual shares received with the expected shares calculated by `previewDeposit()`.

The assertion uses the following cheatcodes:
- `registerCallTrigger()`: Sets up the assertion to be triggered whenever a deposit call is made to the ERC4626 vault
- `getCallInputs()`: Retrieves the input data (assets and receiver) from all deposit calls that triggered the assertion
- `forkPreState()`: Creates a fork of the state before the deposit to capture initial balances
- `forkPostState()`: Creates a fork of the state after the deposit to verify that the actual changes match the expected changes

This multi-layered approach ensures that:
1. Total assets are correctly updated after deposits - the vault's total assets must increase by exactly the deposited amount
2. Share calculations are accurate and consistent with the preview function - the actual shares received must exactly match what `previewDeposit` predicted
3. User balances are properly incremented with the correct share amount - the receiver's balance must increase by exactly the expected shares

The assertion specifically checks that there is no discrepancy between what the preview function predicts and what actually happens during the deposit. This is critical because any mismatch could lead to users receiving incorrect amounts of shares, potentially resulting in loss of value.

For more information about cheatcodes, see the [Cheatcodes Documentation](/credible/cheatcodes).

## Code Example
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

import {Assertion} from "credible-std/Assertion.sol";
import {PhEvm} from "credible-std/PhEvm.sol";

interface IERC4626 {
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function previewDeposit(uint256 assets) external view returns (uint256);
    function totalAssets() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

contract ERC4626DepositAssertion is Assertion {
    IERC4626 public erc4626 = IERC4626(address(0xbeef));

    function triggers() external view override {
        // Register trigger for deposit calls to the ERC4626 vault
        registerCallTrigger(this.assertionDepositAssets.selector, erc4626.deposit.selector);
        registerCallTrigger(this.assertionDepositShares.selector, erc4626.deposit.selector);
    }

    // Assert that deposits correctly update total assets
    function assertionDepositAssets() external {
        // Get all deposit calls to the ERC4626 vault
        PhEvm.CallInputs[] memory callInputs = ph.getCallInputs(address(erc4626), erc4626.deposit.selector);
        
        // First, do a simple pre/post state check for the overall transaction
        ph.forkPreState();
        uint256 preTotalAssets = erc4626.totalAssets();
        
        // Get post-state values
        ph.forkPostState();
        uint256 postTotalAssets = erc4626.totalAssets();
        
        // Calculate total assets deposited across all calls
        uint256 totalAssetsDeposited = 0;
        for (uint256 i = 0; i < callInputs.length; i++) {
            (uint256 assets, ) = abi.decode(callInputs[i].input, (uint256, address));
            totalAssetsDeposited += assets;
        }
        
        // Verify total assets increased by exactly the deposited amount
        require(postTotalAssets == preTotalAssets + totalAssetsDeposited, 
                "Deposit assets assertion failed: incorrect total assets");
    }

    // Assert that deposits maintain correct share accounting
    function assertionDepositShares() external {
        // Get all deposit calls to the ERC4626 vault
        PhEvm.CallInputs[] memory callInputs = ph.getCallInputs(address(erc4626), erc4626.deposit.selector);
        
        // Check each deposit call for correct share accounting
        for (uint256 i = 0; i < callInputs.length; i++) {
            (uint256 assets, address receiver) = abi.decode(callInputs[i].input, (uint256, address));
            
            // Calculate expected shares to be minted for this deposit
            uint256 expectedSharesToMint = erc4626.previewDeposit(assets);
            
            // Get pre-state share balance for this specific receiver
            ph.forkPreState();
            uint256 preShareBalance = erc4626.balanceOf(receiver);
            
            // Get post-state share balance for this specific receiver
            ph.forkPostState();
            uint256 postShareBalance = erc4626.balanceOf(receiver);
            
            // Verify that the receiver received exactly the expected number of shares
            require(postShareBalance == expectedSharesToMint + preShareBalance, 
                    "Deposit shares assertion failed: receiver did not receive expected number of shares");
        }
    }
}
```

> **Note:** This code example is maintained in the [Phylax Assertion Examples Repository](https://github.com/phylaxsystems/assertion-examples/blob/main/assertions/assertions_book/). For the latest version and a test example, please refer to the repository.

## Testing
To test this assertion:
1. Deploy an ERC4626 vault with known asset and share calculation logic
2. Perform deposits with various asset amounts
3. Verify that both assertions correctly identify any discrepancies:
   - Between total assets before and after deposits
   - Between preview shares and actual shares received
4. Test edge cases like zero deposits and maximum deposits

## Assertion Best Practices
- Use both assertions together for comprehensive security verification
- The asset check is simpler and can fail fast if there's an issue
- The share check provides detailed verification of share calculation accuracy
- Add checks for withdraw operations to ensure they maintain correct share accounting
- Consider adding checks for rounding errors in share calculations

## Related Assertions
- [ERC4626 Assets to Shares](/assertions-book/assertions/ass12-erc4626-assets-to-shares)
