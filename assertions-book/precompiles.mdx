---
title: PhEVM Precompiles
description: Overview of the precompiles made available for the Phylax Credible Layer
---


## Overview

Precompiles are PhEVM (Phylax EVM) specific instructions that are implemented in native code instead of EVM bytecode. Precompiles additionally can communicate with Internal APIs. Currently the PhEVM supports all existing precompiles in Ethereum up to Dancun, and introduces a few new classes of precompiles:

1. Manipulation of the PhEVM state
2. Forking of the state of one or multiple EVM networks
3. Utilities that make assertions more useful and easier to write

### Precompile Interface

A list of available precompiles available in the Credible Layer as follows:

#### `load`

Loads a storage slot from an address.

```solidity
function load(address target, bytes32 slot) external view returns (bytes32 data)
```

### Forking

#### `forkPreState`

Updates the currently active fork to the state before the transaction that triggered the assertion.
This is useful for asserting the state of the chain before a transaction is applied.
It's also useful for comparing a value from the pre-state to the post-state.

```solidity
function forkPreState() external
```

#### `forkPostState`

Updates the currently active fork to the state after the transaction that triggered the assertion.
This is useful for asserting the state of the chain after a transaction is applied.
It's also useful for comparing a value from the pre-state to the post-state.

```solidity
function forkPostState() external
```

### Getters

#### `getLogs`

Gets all the logs that were emitted by the latest applied transaction.

```solidity

/// An Ethereum log
struct Log {
    // The topics of the log, including the signature, if any.
    bytes32[] topics;
    // The raw data of the log.
    bytes data;
    // The address of the log's emitter.
    address emitter;
}

function getLogs() external returns (Log[] memory logs)
```

#### `getCallInputs`

Gets the call inputs of all the calls made in the current transaction and returns them in an array of `CallInputs` structs.
This is a useful precompile to use for intra-transaction assertions such as checking if the price reported by an oracle deviates from an allowed range, which could be a sign of an oracle manipulation.

```solidity
// Call inputs for the getCallInputs precompile
struct CallInputs {
    // The call data of the call.
    bytes input;
    /// The gas limit of the call.
    uint64 gas_limit;
    // The account address of bytecode that is going to be executed.
    //
    // Previously `context.code_address`.
    address bytecode_address;
    // Target address, this account storage is going to be modified.
    //
    // Previously `context.address`.
    address target_address;
    // This caller is invoking the call.
    //
    // Previously `context.caller`.
    address caller;
    // Call value.
    //
    // NOTE: This value may not necessarily be transferred from caller to callee, see [`CallValue`].
    //
    // Previously `transfer.value` or `context.apparent_value`.
    uint256 value;
}

function getCallInputs(address target, bytes4 selector) external view returns (CallInputs[] memory calls);
```

### Loaders

#### `load`

Loads a storage slot from an address and returns the value as a `bytes32`.

```solidity
function load(address target, bytes32 slot) external view returns (bytes32 data)
```